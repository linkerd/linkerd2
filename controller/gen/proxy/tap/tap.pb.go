// Code generated by protoc-gen-go. DO NOT EDIT.
// source: proxy/tap/tap.proto

/*
Package conduit_proxy_tap is a generated protocol buffer package.

It is generated from these files:
	proxy/tap/tap.proto

It has these top-level messages:
	ObserveRequest
*/
package conduit_proxy_tap

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import conduit_common "github.com/runconduit/conduit/controller/gen/common"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ObserveRequest struct {
	// Limits the number of event keys that will be returned by this tap.
	Limit uint32 `protobuf:"varint,1,opt,name=limit" json:"limit,omitempty"`
	// Encodes request-matching logic.
	Match *ObserveRequest_Match `protobuf:"bytes,2,opt,name=match" json:"match,omitempty"`
}

func (m *ObserveRequest) Reset()                    { *m = ObserveRequest{} }
func (m *ObserveRequest) String() string            { return proto.CompactTextString(m) }
func (*ObserveRequest) ProtoMessage()               {}
func (*ObserveRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ObserveRequest) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ObserveRequest) GetMatch() *ObserveRequest_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

type ObserveRequest_Match struct {
	// Types that are valid to be assigned to Match:
	//	*ObserveRequest_Match_All
	//	*ObserveRequest_Match_Any
	//	*ObserveRequest_Match_Not
	//	*ObserveRequest_Match_Source
	//	*ObserveRequest_Match_Destination
	//	*ObserveRequest_Match_Http_
	Match isObserveRequest_Match_Match `protobuf_oneof:"match"`
}

func (m *ObserveRequest_Match) Reset()                    { *m = ObserveRequest_Match{} }
func (m *ObserveRequest_Match) String() string            { return proto.CompactTextString(m) }
func (*ObserveRequest_Match) ProtoMessage()               {}
func (*ObserveRequest_Match) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

type isObserveRequest_Match_Match interface {
	isObserveRequest_Match_Match()
}

type ObserveRequest_Match_All struct {
	All *ObserveRequest_Match_Seq `protobuf:"bytes,1,opt,name=all,oneof"`
}
type ObserveRequest_Match_Any struct {
	Any *ObserveRequest_Match_Seq `protobuf:"bytes,2,opt,name=any,oneof"`
}
type ObserveRequest_Match_Not struct {
	Not *ObserveRequest_Match `protobuf:"bytes,3,opt,name=not,oneof"`
}
type ObserveRequest_Match_Source struct {
	Source *ObserveRequest_Match_Tcp `protobuf:"bytes,4,opt,name=source,oneof"`
}
type ObserveRequest_Match_Destination struct {
	Destination *ObserveRequest_Match_Tcp `protobuf:"bytes,5,opt,name=destination,oneof"`
}
type ObserveRequest_Match_Http_ struct {
	Http *ObserveRequest_Match_Http `protobuf:"bytes,6,opt,name=http,oneof"`
}

func (*ObserveRequest_Match_All) isObserveRequest_Match_Match()         {}
func (*ObserveRequest_Match_Any) isObserveRequest_Match_Match()         {}
func (*ObserveRequest_Match_Not) isObserveRequest_Match_Match()         {}
func (*ObserveRequest_Match_Source) isObserveRequest_Match_Match()      {}
func (*ObserveRequest_Match_Destination) isObserveRequest_Match_Match() {}
func (*ObserveRequest_Match_Http_) isObserveRequest_Match_Match()       {}

func (m *ObserveRequest_Match) GetMatch() isObserveRequest_Match_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *ObserveRequest_Match) GetAll() *ObserveRequest_Match_Seq {
	if x, ok := m.GetMatch().(*ObserveRequest_Match_All); ok {
		return x.All
	}
	return nil
}

func (m *ObserveRequest_Match) GetAny() *ObserveRequest_Match_Seq {
	if x, ok := m.GetMatch().(*ObserveRequest_Match_Any); ok {
		return x.Any
	}
	return nil
}

func (m *ObserveRequest_Match) GetNot() *ObserveRequest_Match {
	if x, ok := m.GetMatch().(*ObserveRequest_Match_Not); ok {
		return x.Not
	}
	return nil
}

func (m *ObserveRequest_Match) GetSource() *ObserveRequest_Match_Tcp {
	if x, ok := m.GetMatch().(*ObserveRequest_Match_Source); ok {
		return x.Source
	}
	return nil
}

func (m *ObserveRequest_Match) GetDestination() *ObserveRequest_Match_Tcp {
	if x, ok := m.GetMatch().(*ObserveRequest_Match_Destination); ok {
		return x.Destination
	}
	return nil
}

func (m *ObserveRequest_Match) GetHttp() *ObserveRequest_Match_Http {
	if x, ok := m.GetMatch().(*ObserveRequest_Match_Http_); ok {
		return x.Http
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ObserveRequest_Match) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ObserveRequest_Match_OneofMarshaler, _ObserveRequest_Match_OneofUnmarshaler, _ObserveRequest_Match_OneofSizer, []interface{}{
		(*ObserveRequest_Match_All)(nil),
		(*ObserveRequest_Match_Any)(nil),
		(*ObserveRequest_Match_Not)(nil),
		(*ObserveRequest_Match_Source)(nil),
		(*ObserveRequest_Match_Destination)(nil),
		(*ObserveRequest_Match_Http_)(nil),
	}
}

func _ObserveRequest_Match_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ObserveRequest_Match)
	// match
	switch x := m.Match.(type) {
	case *ObserveRequest_Match_All:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.All); err != nil {
			return err
		}
	case *ObserveRequest_Match_Any:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Any); err != nil {
			return err
		}
	case *ObserveRequest_Match_Not:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Not); err != nil {
			return err
		}
	case *ObserveRequest_Match_Source:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Source); err != nil {
			return err
		}
	case *ObserveRequest_Match_Destination:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Destination); err != nil {
			return err
		}
	case *ObserveRequest_Match_Http_:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Http); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ObserveRequest_Match.Match has unexpected type %T", x)
	}
	return nil
}

func _ObserveRequest_Match_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ObserveRequest_Match)
	switch tag {
	case 1: // match.all
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ObserveRequest_Match_Seq)
		err := b.DecodeMessage(msg)
		m.Match = &ObserveRequest_Match_All{msg}
		return true, err
	case 2: // match.any
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ObserveRequest_Match_Seq)
		err := b.DecodeMessage(msg)
		m.Match = &ObserveRequest_Match_Any{msg}
		return true, err
	case 3: // match.not
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ObserveRequest_Match)
		err := b.DecodeMessage(msg)
		m.Match = &ObserveRequest_Match_Not{msg}
		return true, err
	case 4: // match.source
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ObserveRequest_Match_Tcp)
		err := b.DecodeMessage(msg)
		m.Match = &ObserveRequest_Match_Source{msg}
		return true, err
	case 5: // match.destination
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ObserveRequest_Match_Tcp)
		err := b.DecodeMessage(msg)
		m.Match = &ObserveRequest_Match_Destination{msg}
		return true, err
	case 6: // match.http
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ObserveRequest_Match_Http)
		err := b.DecodeMessage(msg)
		m.Match = &ObserveRequest_Match_Http_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ObserveRequest_Match_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ObserveRequest_Match)
	// match
	switch x := m.Match.(type) {
	case *ObserveRequest_Match_All:
		s := proto.Size(x.All)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ObserveRequest_Match_Any:
		s := proto.Size(x.Any)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ObserveRequest_Match_Not:
		s := proto.Size(x.Not)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ObserveRequest_Match_Source:
		s := proto.Size(x.Source)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ObserveRequest_Match_Destination:
		s := proto.Size(x.Destination)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ObserveRequest_Match_Http_:
		s := proto.Size(x.Http)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ObserveRequest_Match_Seq struct {
	Matches []*ObserveRequest_Match `protobuf:"bytes,1,rep,name=matches" json:"matches,omitempty"`
}

func (m *ObserveRequest_Match_Seq) Reset()                    { *m = ObserveRequest_Match_Seq{} }
func (m *ObserveRequest_Match_Seq) String() string            { return proto.CompactTextString(m) }
func (*ObserveRequest_Match_Seq) ProtoMessage()               {}
func (*ObserveRequest_Match_Seq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0, 0} }

func (m *ObserveRequest_Match_Seq) GetMatches() []*ObserveRequest_Match {
	if m != nil {
		return m.Matches
	}
	return nil
}

type ObserveRequest_Match_Tcp struct {
	// Types that are valid to be assigned to Match:
	//	*ObserveRequest_Match_Tcp_Netmask_
	//	*ObserveRequest_Match_Tcp_Ports
	Match isObserveRequest_Match_Tcp_Match `protobuf_oneof:"match"`
}

func (m *ObserveRequest_Match_Tcp) Reset()                    { *m = ObserveRequest_Match_Tcp{} }
func (m *ObserveRequest_Match_Tcp) String() string            { return proto.CompactTextString(m) }
func (*ObserveRequest_Match_Tcp) ProtoMessage()               {}
func (*ObserveRequest_Match_Tcp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0, 1} }

type isObserveRequest_Match_Tcp_Match interface {
	isObserveRequest_Match_Tcp_Match()
}

type ObserveRequest_Match_Tcp_Netmask_ struct {
	Netmask *ObserveRequest_Match_Tcp_Netmask `protobuf:"bytes,1,opt,name=netmask,oneof"`
}
type ObserveRequest_Match_Tcp_Ports struct {
	Ports *ObserveRequest_Match_Tcp_PortRange `protobuf:"bytes,3,opt,name=ports,oneof"`
}

func (*ObserveRequest_Match_Tcp_Netmask_) isObserveRequest_Match_Tcp_Match() {}
func (*ObserveRequest_Match_Tcp_Ports) isObserveRequest_Match_Tcp_Match()    {}

func (m *ObserveRequest_Match_Tcp) GetMatch() isObserveRequest_Match_Tcp_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *ObserveRequest_Match_Tcp) GetNetmask() *ObserveRequest_Match_Tcp_Netmask {
	if x, ok := m.GetMatch().(*ObserveRequest_Match_Tcp_Netmask_); ok {
		return x.Netmask
	}
	return nil
}

func (m *ObserveRequest_Match_Tcp) GetPorts() *ObserveRequest_Match_Tcp_PortRange {
	if x, ok := m.GetMatch().(*ObserveRequest_Match_Tcp_Ports); ok {
		return x.Ports
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ObserveRequest_Match_Tcp) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ObserveRequest_Match_Tcp_OneofMarshaler, _ObserveRequest_Match_Tcp_OneofUnmarshaler, _ObserveRequest_Match_Tcp_OneofSizer, []interface{}{
		(*ObserveRequest_Match_Tcp_Netmask_)(nil),
		(*ObserveRequest_Match_Tcp_Ports)(nil),
	}
}

func _ObserveRequest_Match_Tcp_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ObserveRequest_Match_Tcp)
	// match
	switch x := m.Match.(type) {
	case *ObserveRequest_Match_Tcp_Netmask_:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Netmask); err != nil {
			return err
		}
	case *ObserveRequest_Match_Tcp_Ports:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ports); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ObserveRequest_Match_Tcp.Match has unexpected type %T", x)
	}
	return nil
}

func _ObserveRequest_Match_Tcp_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ObserveRequest_Match_Tcp)
	switch tag {
	case 1: // match.netmask
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ObserveRequest_Match_Tcp_Netmask)
		err := b.DecodeMessage(msg)
		m.Match = &ObserveRequest_Match_Tcp_Netmask_{msg}
		return true, err
	case 3: // match.ports
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ObserveRequest_Match_Tcp_PortRange)
		err := b.DecodeMessage(msg)
		m.Match = &ObserveRequest_Match_Tcp_Ports{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ObserveRequest_Match_Tcp_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ObserveRequest_Match_Tcp)
	// match
	switch x := m.Match.(type) {
	case *ObserveRequest_Match_Tcp_Netmask_:
		s := proto.Size(x.Netmask)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ObserveRequest_Match_Tcp_Ports:
		s := proto.Size(x.Ports)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ObserveRequest_Match_Tcp_Netmask struct {
	Ip   *conduit_common.IPAddress `protobuf:"bytes,1,opt,name=ip" json:"ip,omitempty"`
	Mask uint32                    `protobuf:"varint,2,opt,name=mask" json:"mask,omitempty"`
}

func (m *ObserveRequest_Match_Tcp_Netmask) Reset()         { *m = ObserveRequest_Match_Tcp_Netmask{} }
func (m *ObserveRequest_Match_Tcp_Netmask) String() string { return proto.CompactTextString(m) }
func (*ObserveRequest_Match_Tcp_Netmask) ProtoMessage()    {}
func (*ObserveRequest_Match_Tcp_Netmask) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{0, 0, 1, 0}
}

func (m *ObserveRequest_Match_Tcp_Netmask) GetIp() *conduit_common.IPAddress {
	if m != nil {
		return m.Ip
	}
	return nil
}

func (m *ObserveRequest_Match_Tcp_Netmask) GetMask() uint32 {
	if m != nil {
		return m.Mask
	}
	return 0
}

// If either a minimum or maximum is not specified, the range is considered to be
// over a discrete value.
type ObserveRequest_Match_Tcp_PortRange struct {
	// Minimum matching port value (inclusive), if specified.
	Min uint32 `protobuf:"varint,1,opt,name=min" json:"min,omitempty"`
	// Maximum matching port value (inclusive), if specified.
	Max uint32 `protobuf:"varint,2,opt,name=max" json:"max,omitempty"`
}

func (m *ObserveRequest_Match_Tcp_PortRange) Reset()         { *m = ObserveRequest_Match_Tcp_PortRange{} }
func (m *ObserveRequest_Match_Tcp_PortRange) String() string { return proto.CompactTextString(m) }
func (*ObserveRequest_Match_Tcp_PortRange) ProtoMessage()    {}
func (*ObserveRequest_Match_Tcp_PortRange) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{0, 0, 1, 1}
}

func (m *ObserveRequest_Match_Tcp_PortRange) GetMin() uint32 {
	if m != nil {
		return m.Min
	}
	return 0
}

func (m *ObserveRequest_Match_Tcp_PortRange) GetMax() uint32 {
	if m != nil {
		return m.Max
	}
	return 0
}

type ObserveRequest_Match_Http struct {
	// Types that are valid to be assigned to Match:
	//	*ObserveRequest_Match_Http_Scheme
	//	*ObserveRequest_Match_Http_Method
	//	*ObserveRequest_Match_Http_Authority
	//	*ObserveRequest_Match_Http_Path
	Match isObserveRequest_Match_Http_Match `protobuf_oneof:"match"`
}

func (m *ObserveRequest_Match_Http) Reset()                    { *m = ObserveRequest_Match_Http{} }
func (m *ObserveRequest_Match_Http) String() string            { return proto.CompactTextString(m) }
func (*ObserveRequest_Match_Http) ProtoMessage()               {}
func (*ObserveRequest_Match_Http) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0, 2} }

type isObserveRequest_Match_Http_Match interface {
	isObserveRequest_Match_Http_Match()
}

type ObserveRequest_Match_Http_Scheme struct {
	Scheme *conduit_common.Scheme `protobuf:"bytes,1,opt,name=scheme,oneof"`
}
type ObserveRequest_Match_Http_Method struct {
	Method *conduit_common.HttpMethod `protobuf:"bytes,3,opt,name=method,oneof"`
}
type ObserveRequest_Match_Http_Authority struct {
	Authority *ObserveRequest_Match_Http_StringMatch `protobuf:"bytes,2,opt,name=authority,oneof"`
}
type ObserveRequest_Match_Http_Path struct {
	Path *ObserveRequest_Match_Http_StringMatch `protobuf:"bytes,4,opt,name=path,oneof"`
}

func (*ObserveRequest_Match_Http_Scheme) isObserveRequest_Match_Http_Match()    {}
func (*ObserveRequest_Match_Http_Method) isObserveRequest_Match_Http_Match()    {}
func (*ObserveRequest_Match_Http_Authority) isObserveRequest_Match_Http_Match() {}
func (*ObserveRequest_Match_Http_Path) isObserveRequest_Match_Http_Match()      {}

func (m *ObserveRequest_Match_Http) GetMatch() isObserveRequest_Match_Http_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *ObserveRequest_Match_Http) GetScheme() *conduit_common.Scheme {
	if x, ok := m.GetMatch().(*ObserveRequest_Match_Http_Scheme); ok {
		return x.Scheme
	}
	return nil
}

func (m *ObserveRequest_Match_Http) GetMethod() *conduit_common.HttpMethod {
	if x, ok := m.GetMatch().(*ObserveRequest_Match_Http_Method); ok {
		return x.Method
	}
	return nil
}

func (m *ObserveRequest_Match_Http) GetAuthority() *ObserveRequest_Match_Http_StringMatch {
	if x, ok := m.GetMatch().(*ObserveRequest_Match_Http_Authority); ok {
		return x.Authority
	}
	return nil
}

func (m *ObserveRequest_Match_Http) GetPath() *ObserveRequest_Match_Http_StringMatch {
	if x, ok := m.GetMatch().(*ObserveRequest_Match_Http_Path); ok {
		return x.Path
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ObserveRequest_Match_Http) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ObserveRequest_Match_Http_OneofMarshaler, _ObserveRequest_Match_Http_OneofUnmarshaler, _ObserveRequest_Match_Http_OneofSizer, []interface{}{
		(*ObserveRequest_Match_Http_Scheme)(nil),
		(*ObserveRequest_Match_Http_Method)(nil),
		(*ObserveRequest_Match_Http_Authority)(nil),
		(*ObserveRequest_Match_Http_Path)(nil),
	}
}

func _ObserveRequest_Match_Http_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ObserveRequest_Match_Http)
	// match
	switch x := m.Match.(type) {
	case *ObserveRequest_Match_Http_Scheme:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Scheme); err != nil {
			return err
		}
	case *ObserveRequest_Match_Http_Method:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Method); err != nil {
			return err
		}
	case *ObserveRequest_Match_Http_Authority:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Authority); err != nil {
			return err
		}
	case *ObserveRequest_Match_Http_Path:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Path); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ObserveRequest_Match_Http.Match has unexpected type %T", x)
	}
	return nil
}

func _ObserveRequest_Match_Http_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ObserveRequest_Match_Http)
	switch tag {
	case 1: // match.scheme
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(conduit_common.Scheme)
		err := b.DecodeMessage(msg)
		m.Match = &ObserveRequest_Match_Http_Scheme{msg}
		return true, err
	case 3: // match.method
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(conduit_common.HttpMethod)
		err := b.DecodeMessage(msg)
		m.Match = &ObserveRequest_Match_Http_Method{msg}
		return true, err
	case 2: // match.authority
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ObserveRequest_Match_Http_StringMatch)
		err := b.DecodeMessage(msg)
		m.Match = &ObserveRequest_Match_Http_Authority{msg}
		return true, err
	case 4: // match.path
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ObserveRequest_Match_Http_StringMatch)
		err := b.DecodeMessage(msg)
		m.Match = &ObserveRequest_Match_Http_Path{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ObserveRequest_Match_Http_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ObserveRequest_Match_Http)
	// match
	switch x := m.Match.(type) {
	case *ObserveRequest_Match_Http_Scheme:
		s := proto.Size(x.Scheme)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ObserveRequest_Match_Http_Method:
		s := proto.Size(x.Method)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ObserveRequest_Match_Http_Authority:
		s := proto.Size(x.Authority)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ObserveRequest_Match_Http_Path:
		s := proto.Size(x.Path)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ObserveRequest_Match_Http_StringMatch struct {
	// Types that are valid to be assigned to Match:
	//	*ObserveRequest_Match_Http_StringMatch_Exact
	//	*ObserveRequest_Match_Http_StringMatch_Prefix
	Match isObserveRequest_Match_Http_StringMatch_Match `protobuf_oneof:"match"`
}

func (m *ObserveRequest_Match_Http_StringMatch) Reset()         { *m = ObserveRequest_Match_Http_StringMatch{} }
func (m *ObserveRequest_Match_Http_StringMatch) String() string { return proto.CompactTextString(m) }
func (*ObserveRequest_Match_Http_StringMatch) ProtoMessage()    {}
func (*ObserveRequest_Match_Http_StringMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{0, 0, 2, 0}
}

type isObserveRequest_Match_Http_StringMatch_Match interface {
	isObserveRequest_Match_Http_StringMatch_Match()
}

type ObserveRequest_Match_Http_StringMatch_Exact struct {
	Exact string `protobuf:"bytes,1,opt,name=exact,oneof"`
}
type ObserveRequest_Match_Http_StringMatch_Prefix struct {
	Prefix string `protobuf:"bytes,2,opt,name=prefix,oneof"`
}

func (*ObserveRequest_Match_Http_StringMatch_Exact) isObserveRequest_Match_Http_StringMatch_Match()  {}
func (*ObserveRequest_Match_Http_StringMatch_Prefix) isObserveRequest_Match_Http_StringMatch_Match() {}

func (m *ObserveRequest_Match_Http_StringMatch) GetMatch() isObserveRequest_Match_Http_StringMatch_Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *ObserveRequest_Match_Http_StringMatch) GetExact() string {
	if x, ok := m.GetMatch().(*ObserveRequest_Match_Http_StringMatch_Exact); ok {
		return x.Exact
	}
	return ""
}

func (m *ObserveRequest_Match_Http_StringMatch) GetPrefix() string {
	if x, ok := m.GetMatch().(*ObserveRequest_Match_Http_StringMatch_Prefix); ok {
		return x.Prefix
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ObserveRequest_Match_Http_StringMatch) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ObserveRequest_Match_Http_StringMatch_OneofMarshaler, _ObserveRequest_Match_Http_StringMatch_OneofUnmarshaler, _ObserveRequest_Match_Http_StringMatch_OneofSizer, []interface{}{
		(*ObserveRequest_Match_Http_StringMatch_Exact)(nil),
		(*ObserveRequest_Match_Http_StringMatch_Prefix)(nil),
	}
}

func _ObserveRequest_Match_Http_StringMatch_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ObserveRequest_Match_Http_StringMatch)
	// match
	switch x := m.Match.(type) {
	case *ObserveRequest_Match_Http_StringMatch_Exact:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Exact)
	case *ObserveRequest_Match_Http_StringMatch_Prefix:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Prefix)
	case nil:
	default:
		return fmt.Errorf("ObserveRequest_Match_Http_StringMatch.Match has unexpected type %T", x)
	}
	return nil
}

func _ObserveRequest_Match_Http_StringMatch_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ObserveRequest_Match_Http_StringMatch)
	switch tag {
	case 1: // match.exact
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Match = &ObserveRequest_Match_Http_StringMatch_Exact{x}
		return true, err
	case 2: // match.prefix
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Match = &ObserveRequest_Match_Http_StringMatch_Prefix{x}
		return true, err
	default:
		return false, nil
	}
}

func _ObserveRequest_Match_Http_StringMatch_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ObserveRequest_Match_Http_StringMatch)
	// match
	switch x := m.Match.(type) {
	case *ObserveRequest_Match_Http_StringMatch_Exact:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Exact)))
		n += len(x.Exact)
	case *ObserveRequest_Match_Http_StringMatch_Prefix:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Prefix)))
		n += len(x.Prefix)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*ObserveRequest)(nil), "conduit.proxy.tap.ObserveRequest")
	proto.RegisterType((*ObserveRequest_Match)(nil), "conduit.proxy.tap.ObserveRequest.Match")
	proto.RegisterType((*ObserveRequest_Match_Seq)(nil), "conduit.proxy.tap.ObserveRequest.Match.Seq")
	proto.RegisterType((*ObserveRequest_Match_Tcp)(nil), "conduit.proxy.tap.ObserveRequest.Match.Tcp")
	proto.RegisterType((*ObserveRequest_Match_Tcp_Netmask)(nil), "conduit.proxy.tap.ObserveRequest.Match.Tcp.Netmask")
	proto.RegisterType((*ObserveRequest_Match_Tcp_PortRange)(nil), "conduit.proxy.tap.ObserveRequest.Match.Tcp.PortRange")
	proto.RegisterType((*ObserveRequest_Match_Http)(nil), "conduit.proxy.tap.ObserveRequest.Match.Http")
	proto.RegisterType((*ObserveRequest_Match_Http_StringMatch)(nil), "conduit.proxy.tap.ObserveRequest.Match.Http.StringMatch")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Tap service

type TapClient interface {
	Observe(ctx context.Context, in *ObserveRequest, opts ...grpc.CallOption) (Tap_ObserveClient, error)
}

type tapClient struct {
	cc *grpc.ClientConn
}

func NewTapClient(cc *grpc.ClientConn) TapClient {
	return &tapClient{cc}
}

func (c *tapClient) Observe(ctx context.Context, in *ObserveRequest, opts ...grpc.CallOption) (Tap_ObserveClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Tap_serviceDesc.Streams[0], c.cc, "/conduit.proxy.tap.Tap/Observe", opts...)
	if err != nil {
		return nil, err
	}
	x := &tapObserveClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Tap_ObserveClient interface {
	Recv() (*conduit_common.TapEvent, error)
	grpc.ClientStream
}

type tapObserveClient struct {
	grpc.ClientStream
}

func (x *tapObserveClient) Recv() (*conduit_common.TapEvent, error) {
	m := new(conduit_common.TapEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Tap service

type TapServer interface {
	Observe(*ObserveRequest, Tap_ObserveServer) error
}

func RegisterTapServer(s *grpc.Server, srv TapServer) {
	s.RegisterService(&_Tap_serviceDesc, srv)
}

func _Tap_Observe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ObserveRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TapServer).Observe(m, &tapObserveServer{stream})
}

type Tap_ObserveServer interface {
	Send(*conduit_common.TapEvent) error
	grpc.ServerStream
}

type tapObserveServer struct {
	grpc.ServerStream
}

func (x *tapObserveServer) Send(m *conduit_common.TapEvent) error {
	return x.ServerStream.SendMsg(m)
}

var _Tap_serviceDesc = grpc.ServiceDesc{
	ServiceName: "conduit.proxy.tap.Tap",
	HandlerType: (*TapServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Observe",
			Handler:       _Tap_Observe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proxy/tap/tap.proto",
}

func init() { proto.RegisterFile("proxy/tap/tap.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 553 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x94, 0xc1, 0x6e, 0xd3, 0x4c,
	0x10, 0xc7, 0x13, 0x3b, 0x76, 0x94, 0x89, 0xbe, 0x4f, 0x30, 0x45, 0x95, 0xf1, 0xa9, 0xf4, 0x42,
	0x11, 0xc8, 0xa9, 0x52, 0x90, 0x90, 0x10, 0x42, 0xad, 0x54, 0xc9, 0x20, 0xa5, 0x29, 0x4e, 0x0e,
	0x5c, 0xb7, 0xce, 0x52, 0x5b, 0xc4, 0xbb, 0x1b, 0x7b, 0x52, 0x25, 0x4f, 0xc1, 0x73, 0xf0, 0x6c,
	0x3c, 0x00, 0x57, 0xb4, 0xeb, 0x4d, 0x28, 0xe9, 0x81, 0x1a, 0x0e, 0x96, 0x67, 0x77, 0xe7, 0xff,
	0xdb, 0xd9, 0x99, 0x9d, 0x85, 0x3d, 0x55, 0xca, 0xd5, 0x7a, 0x40, 0x4c, 0xe9, 0x2f, 0x52, 0xa5,
	0x24, 0x89, 0x0f, 0x53, 0x29, 0x66, 0xcb, 0x9c, 0x22, 0xb3, 0x18, 0x11, 0x53, 0xe1, 0x5e, 0x2a,
	0x8b, 0x42, 0x8a, 0x41, 0xfd, 0xab, 0xfd, 0x0e, 0x7f, 0xf4, 0xe0, 0xff, 0xf1, 0x55, 0xc5, 0xcb,
	0x1b, 0x9e, 0xf0, 0xc5, 0x92, 0x57, 0x84, 0x8f, 0xc0, 0x9b, 0xe7, 0x45, 0x4e, 0x41, 0xfb, 0xa0,
	0x7d, 0xf4, 0x5f, 0x52, 0x0f, 0xf0, 0x2d, 0x78, 0x05, 0xa3, 0x34, 0x0b, 0x9c, 0x83, 0xf6, 0x51,
	0x7f, 0xf8, 0x34, 0xba, 0xb3, 0x41, 0xf4, 0x3b, 0x27, 0x1a, 0x69, 0xf7, 0xa4, 0x56, 0x85, 0x5f,
	0x7b, 0xe0, 0x99, 0x09, 0x7c, 0x07, 0x2e, 0x9b, 0xcf, 0x0d, 0xbc, 0x3f, 0x7c, 0x7e, 0x4f, 0x4c,
	0x34, 0xe1, 0x8b, 0xb8, 0x95, 0x68, 0xa5, 0x01, 0x88, 0xb5, 0x8d, 0xa3, 0x31, 0x40, 0xac, 0xf1,
	0x0d, 0xb8, 0x42, 0x52, 0xe0, 0x36, 0x3a, 0x88, 0x16, 0x0b, 0x49, 0x78, 0x0e, 0x7e, 0x25, 0x97,
	0x65, 0xca, 0x83, 0x4e, 0xb3, 0x00, 0xa6, 0xa9, 0x8a, 0x5b, 0x89, 0x15, 0xe3, 0x18, 0xfa, 0x33,
	0x5e, 0x51, 0x2e, 0x18, 0xe5, 0x52, 0x04, 0xde, 0xdf, 0xb0, 0x6e, 0x13, 0xf0, 0x0c, 0x3a, 0x19,
	0x91, 0x0a, 0x7c, 0x43, 0x7a, 0x71, 0x5f, 0x52, 0x4c, 0xa4, 0x51, 0x46, 0x1b, 0xc6, 0xe0, 0x4e,
	0xf8, 0x02, 0x4f, 0xa1, 0x6b, 0x8a, 0xc6, 0xab, 0xa0, 0x7d, 0xe0, 0x36, 0x29, 0xf6, 0x46, 0x17,
	0x7e, 0x73, 0xc0, 0x9d, 0xa6, 0x0a, 0xc7, 0xd0, 0x15, 0x9c, 0x0a, 0x56, 0x7d, 0xb1, 0x05, 0x3f,
	0x69, 0x70, 0xc4, 0xe8, 0xa2, 0x96, 0xc6, 0xad, 0x64, 0x43, 0xc1, 0x11, 0x78, 0x4a, 0x96, 0x54,
	0xd9, 0xea, 0xbd, 0x6a, 0x82, 0xbb, 0x94, 0x25, 0x25, 0x4c, 0x5c, 0xf3, 0xb8, 0x95, 0xd4, 0x94,
	0x30, 0x86, 0xae, 0xdd, 0x04, 0x9f, 0x81, 0x93, 0x2b, 0x1b, 0xe5, 0xe3, 0x2d, 0xd6, 0x36, 0xcb,
	0xfb, 0xcb, 0xd3, 0xd9, 0xac, 0xe4, 0x55, 0x95, 0x38, 0xb9, 0x42, 0x84, 0x8e, 0x39, 0x92, 0x63,
	0x1a, 0xc4, 0xd8, 0xe1, 0x00, 0x7a, 0x5b, 0x3e, 0x3e, 0x00, 0xb7, 0xc8, 0x85, 0x6d, 0x20, 0x6d,
	0x9a, 0x19, 0xb6, 0xb2, 0x0a, 0x6d, 0x9e, 0x75, 0x6d, 0x43, 0x85, 0xdf, 0x1d, 0xe8, 0xe8, 0x32,
	0xe0, 0x31, 0xf8, 0x55, 0x9a, 0xf1, 0x82, 0xdb, 0x28, 0xf6, 0x77, 0xa3, 0x98, 0x98, 0x55, 0x73,
	0x8b, 0x8c, 0x85, 0x2f, 0xc1, 0x2f, 0x38, 0x65, 0x72, 0x66, 0xd3, 0x11, 0xee, 0x2a, 0x34, 0x77,
	0x64, 0x3c, 0xb4, 0xaa, 0xf6, 0xc5, 0x4f, 0xd0, 0x63, 0x4b, 0xca, 0x64, 0x99, 0xd3, 0xa6, 0x8d,
	0x5e, 0x37, 0xb9, 0x2f, 0xd1, 0x84, 0xca, 0x5c, 0x5c, 0x6f, 0xda, 0xe2, 0x17, 0x0c, 0x2f, 0xa0,
	0xa3, 0x18, 0x65, 0xb6, 0x35, 0xfe, 0x05, 0x6a, 0x38, 0x61, 0x0c, 0xfd, 0x5b, 0xd3, 0xb8, 0x0f,
	0x1e, 0x5f, 0xb1, 0xb4, 0x7e, 0x99, 0x7a, 0xba, 0x8a, 0x66, 0x88, 0x01, 0xf8, 0xaa, 0xe4, 0x9f,
	0xf3, 0x3a, 0xbf, 0x7a, 0xc1, 0x8e, 0xb7, 0x49, 0xbe, 0x6b, 0x0c, 0x3f, 0x82, 0x3b, 0x65, 0x0a,
	0x3f, 0x40, 0xd7, 0xc6, 0x84, 0x4f, 0xfe, 0x18, 0x6f, 0x18, 0xec, 0x26, 0x78, 0xca, 0xd4, 0xf9,
	0x0d, 0x17, 0x74, 0xd8, 0x3a, 0x6e, 0x5f, 0xf9, 0xe6, 0x4d, 0x3d, 0xf9, 0x19, 0x00, 0x00, 0xff,
	0xff, 0x72, 0x21, 0x20, 0xc9, 0x92, 0x05, 0x00, 0x00,
}
